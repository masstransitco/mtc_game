<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>MTC Mini Game - Single File</title>

    <!-- Inline CSS -->
    <style>
      /* BASIC RESET & BODY */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        width: 100%;
        overflow: hidden;
        font-family: Arial, sans-serif;
        background-color: #1C262D; /* Dark theme background */
        color: #ffffff;
      }

      /* START SCREEN */
      #start-screen {
        position: fixed;
        top: 0;
        left: 0;
        height: 100%;
        width: 100%;
        background: #000000;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 999; /* On top of everything else */
      }
      #start-overlay {
        text-align: center;
      }
      #start-overlay h1 {
        font-size: 2rem;
        margin-bottom: 1rem;
        color: #fff;
        text-transform: uppercase;
        letter-spacing: 3px;
      }
      #play-button {
        font-size: 1.2rem;
        padding: 0.8rem 1.6rem;
        border: none;
        border-radius: 6px;
        background: #0072E9;
        color: #fff;
        cursor: pointer;
        transition: background 0.3s;
      }
      #play-button:hover {
        background: #005bb5;
      }

      /* UI CONTAINER (top-right) */
      #ui-container {
        position: fixed;
        top: 10px;
        right: 10px;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        background: rgba(0, 0, 0, 0.5);
        padding: 10px 20px;
        border-radius: 10px;
        z-index: 20;
      }
      #ui-container div {
        font-size: 16px;
        margin: 5px 0;
        color: #ffffff;
      }

      /* SPEEDOMETER */
      #speedometer {
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 22px;
        color: #ffffff;
        font-family: 'Orbitron', sans-serif;
        text-shadow: 2px 2px 8px rgba(255, 255, 255, 0.8);
        z-index: 20;
      }

      /* WARNING INDICATOR */
      #warningIndicator {
        display: none;
        position: fixed;
        top: 60px;
        left: 50%;
        transform: translateX(-50%);
        width: 50px;
        height: 50px;
        z-index: 25;
      }
      #warningCircle {
        width: 100%;
        height: 100%;
        border: 1.5px solid red;
        border-radius: 50%;
        box-sizing: border-box;
        position: relative;
        background: transparent;
      }
      #warningExclamation {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -55%);
        font-size: 24px;
        color: red;
        font-weight: bold;
        opacity: 0.5;
      }
      /* Flashing animation */
      @keyframes flash {
        0% {
          opacity: 0.5;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.5;
        }
      }
      .flashing {
        animation: flash 1s infinite;
      }

      /* GAME OVER SCREEN */
      #gameOver,
      #gameComplete {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        color: #ffffff;
        background: rgba(0, 0, 0, 0.8);
        padding: 30px;
        border-radius: 10px;
        z-index: 40;
      }
      #gameOver h1,
      #gameComplete h1 {
        margin-bottom: 20px;
      }
      #gameOver button,
      #gameComplete button {
        margin-top: 20px;
        font-size: 18px;
        padding: 10px 20px;
        color: #ffffff;
        background: #0072E9;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
      }
      #gameOver button:hover,
      #gameComplete button:hover {
        background-color: #005bb5;
      }

      /* LEADERBOARD */
      #leaderboard {
        margin-top: 20px;
        text-align: left;
      }
      #leaderboard h2 {
        margin-bottom: 10px;
      }
      #leaderboard ul {
        list-style: none;
        padding: 0;
        max-height: 200px;
        overflow-y: auto;
      }
      #leaderboardList {
        background: rgba(255, 255, 255, 0.1);
        padding: 10px;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }
      #leaderboardList li {
        background: rgba(255, 255, 255, 0.2);
        padding: 5px 10px;
        border-radius: 5px;
        margin-bottom: 5px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      #leaderboardList li span {
        color: #FFFFFF;
      }

      /* NAME INPUT CONTAINER */
      #nameInputContainer {
        margin-top: 20px;
      }
      #nameInput {
        font-size: 18px;
        padding: 5px;
        width: 200px;
        height: 30px;
      }
      #submitNameButton {
        font-size: 24px;
        width: 35px;
        height: 35px;
        padding: 0;
        margin-left: 10px;
        text-align: center;
        line-height: 35px;
        background: #000000;
        color: #FFFFFF;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
      }
      #submitNameButton:hover {
        background-color: #333333;
      }

      /* JOYSTICK CONTAINER */
      #joystick-container {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 100px;
        height: 100px;
        z-index: 30;
        display: block;
        cursor: pointer;
      }
      #joystick-base {
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        position: relative;
        touch-action: none;
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
      }
      #joystick-knob {
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.6);
        border: 2px solid rgba(255, 255, 255, 0.9);
        border-radius: 50%;
        position: absolute;
        top: 25px;
        left: 25px;
        transition: box-shadow 0.3s, transform 0.1s;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }
      #joystick-knob.active {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5);
      }

      /* RESPONSIVE JOYSTICK */
      @media (max-width: 600px) {
        #joystick-container {
          width: 80px;
          height: 80px;
          bottom: 15px;
        }
        #joystick-knob {
          width: 40px;
          height: 40px;
          top: 20px;
          left: 20px;
        }
        #ui-container {
          padding: 8px 16px;
        }
        #bestTime,
        #distance,
        #time,
        #score {
          font-size: 14px;
        }
        #speedometer {
          font-size: 18px;
        }
        #warningIndicator {
          width: 40px;
          height: 40px;
        }
        #warningExclamation {
          font-size: 20px;
        }
      }

      /* INSTRUCTIONS */
      #instructions {
        position: absolute;
        top: 55%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        text-align: center;
        z-index: 35;
        display: none;
      }
    </style>
  </head>

  <body>
    <!-- START SCREEN (Dark Themed) -->
    <div id="start-screen">
      <div id="start-overlay">
        <h1>MTC MINI GAME</h1>
        <button id="play-button">Play</button>
      </div>
    </div>

    <!-- MAIN GAME UI CONTAINERS -->
    <div id="speedometer">-- km/h</div>
    <div id="warningIndicator">
      <div id="warningCircle">
        <div id="warningExclamation">!</div>
      </div>
    </div>
    <div id="ui-container">
      <div id="bestTime">Best Time: N/A</div>
      <div id="distance">Distance: 0 m</div>
      <div id="time">Time: 0 s</div>
      <div id="score">Score: 0</div>
    </div>
    <div id="gameOver">
      <h1>Game Over</h1>
      <p>Driving Time: <span id="finalTime">0</span></p>
      <button id="restartButton">Play Again</button>
      <button id="continueLink">Continue →</button>
    </div>
    <div id="gameComplete">
      <h1>Trip Completed</h1>
      <p>Your Time: <span id="completionTime">0</span></p>
      <div id="leaderboard">
        <h2>Leaderboard</h2>
        <ul id="leaderboardList"></ul>
      </div>
      <div id="nameInputContainer" style="display: none;">
        <p>Enter your name:</p>
        <input type="text" id="nameInput" maxlength="10" />
        <button id="submitNameButton">↑</button>
      </div>
      <button id="restartButtonComplete">Play Again</button>
      <button id="continueLinkComplete">Continue →</button>
    </div>
    <div id="joystick-container">
      <div id="joystick-base">
        <div id="joystick-knob"></div>
      </div>
    </div>
    <div id="instructions">
      <p>Use joystick to accelerate, decelerate, and steer.</p>
      <p>Avoid collisions!</p>
    </div>

    <!-- Load matching versions of Three.js and GLTFLoader (global approach) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <!-- Single <script> with the entire game logic -->
    <script>
      /*********************************************************************
       * SINGLE-FILE SCRIPT
       * Using global THREE, pinned to r149. new THREE.GLTFLoader() works here.
       *********************************************************************/

      let scene, camera, renderer;
      let environmentGroup;
      let MTC;                 // The user’s car
      let userCarLoaded = false;
      let taxiModel;           // Template for obstacle
      let obstacles = [];      // Active obstacles
      let obstaclePool = [];   // Pool for reusing obstacles
      const maxObstacles = 8;  // Limit how many obstacles can exist
      let lanePositions = [-4, -2, 0, 2, 4];

      const baseVelocity = 6.944;    // ~25 km/h in m/s
      const minVelocity = 0.278;     // ~1 km/h
      const maxVelocity = 44.444;    // ~160 km/h
      let velocity = baseVelocity;

      let accelerateInput = false;
      let decelerateInput = false;
      let moveLeft = false;
      let moveRight = false;

      let gameOver = false;
      let gameCompleted = false;
      let collisionCount = 0;

      let distance = 0;       // meters
      let elapsedTime = 0;    // seconds
      let startTime = 0;      // ms
      let previousTime = 0;   // ms
      let animationId;

      let scoreboard = 0;     // A simple “score” system

      // Leaderboard
      let leaderboard = JSON.parse(localStorage.getItem('leaderboard')) || [];

      const obstacleFrequency = 2;   // spawn new obstacle every 2s
      let obstacleTimer = 0;
      let difficultyRamp = 0.0;      // increases obstacle speed over time

      // ============== SETUP SCENE, CAMERA, RENDERER ==================
      function initScene() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1C262D);

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          3000
        );
        camera.position.set(0, 5, 15);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Basic lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        environmentGroup = new THREE.Group();
        scene.add(environmentGroup);

        window.addEventListener('resize', onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // ============== LOAD MODELS (User Car, Obstacle) ==============
      function loadModels() {
        const loader = new THREE.GLTFLoader(); // <-- Works in global approach r149
        // 1) User Car
        loader.load(
          'mtc.glb',
          (gltf) => {
            MTC = gltf.scene;
            MTC.scale.set(2.2, 2.2, 2.2);
            MTC.position.set(0, 1.1, 0);
            MTC.castShadow = true;
            MTC.receiveShadow = true;
            environmentGroup.add(MTC);
            userCarLoaded = true;
          },
          undefined,
          (err) => {
            console.error('Error loading mtc.glb', err);
          }
        );

        // 2) Obstacle (Taxi)
        loader.load(
          'taxi.glb',
          (gltf) => {
            taxiModel = gltf.scene;
            taxiModel.scale.set(0.5, 0.5, 0.5);
            taxiModel.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
          },
          undefined,
          (err) => {
            console.error('Error loading taxi.glb', err);
          }
        );
      }

      // ============== ENVIRONMENT SETUP (Road, etc.) ================
      function setupEnvironment() {
        const roadWidth = 12;
        const roadLength = 2000;
        const roadGeometry = new THREE.PlaneGeometry(roadWidth, roadLength);
        const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2;
        road.position.y = 0;
        road.receiveShadow = true;
        environmentGroup.add(road);

        // Lane markers
        const lanes = lanePositions;
        const markerSpacing = 10; // smaller spacing
        const markerLength = 1;
        for (let z = -roadLength / 2; z < roadLength / 2; z += markerSpacing) {
          lanes.forEach((lane) => {
            const markerGeom = new THREE.BoxGeometry(0.1, 0.01, markerLength);
            const markerMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const marker = new THREE.Mesh(markerGeom, markerMat);
            marker.position.set(lane, 0.01, z);
            marker.rotation.x = -Math.PI / 2;
            environmentGroup.add(marker);
          });
        }

        // Simple “barriers” on left and right
        const barrierHeight = 1.2;
        const barrierWidth = 0.5;
        const barrierGeom = new THREE.BoxGeometry(barrierWidth, barrierHeight, roadLength);
        const barrierMat = new THREE.MeshLambertMaterial({ color: 0xffffff });

        const barrierLeft = new THREE.Mesh(barrierGeom, barrierMat);
        barrierLeft.position.set(-roadWidth / 2 - barrierWidth / 2, barrierHeight / 2, 0);
        barrierLeft.receiveShadow = true;
        barrierLeft.castShadow = true;
        environmentGroup.add(barrierLeft);

        const barrierRight = new THREE.Mesh(barrierGeom, barrierMat);
        barrierRight.position.set(roadWidth / 2 + barrierWidth / 2, barrierHeight / 2, 0);
        barrierRight.receiveShadow = true;
        barrierRight.castShadow = true;
        environmentGroup.add(barrierRight);
      }

      // ============== SETUP OBSTACLE POOL ===========================
      function initObstaclePool() {
        if (!taxiModel) return;
        for (let i = 0; i < maxObstacles; i++) {
          const obstacle = taxiModel.clone();
          obstacle.visible = false;
          environmentGroup.add(obstacle);
          obstaclePool.push(obstacle);
        }
      }
      function getObstacleFromPool() {
        for (let i = 0; i < obstaclePool.length; i++) {
          if (!obstaclePool[i].visible) {
            return obstaclePool[i];
          }
        }
        return null;
      }

      // ============== SPAWN OBSTACLES ===============================
      function spawnObstacle() {
        if (!taxiModel || !userCarLoaded) return;
        const obstacle = getObstacleFromPool();
        if (!obstacle) return;
        obstacle.visible = true;

        const lane = lanePositions[Math.floor(Math.random() * lanePositions.length)];
        const spawnBehind = Math.random() < 0.5;
        let spawnZ;
        const proximity = 60;
        if (spawnBehind) {
          spawnZ = MTC.position.z + (Math.random() * -proximity - 10);
        } else {
          spawnZ = MTC.position.z - 100 - Math.random() * 50;
        }
        obstacle.position.set(lane, 0.2, spawnZ);
        obstacle.rotation.y = Math.PI; // face forward
        obstacle.userData.speed = (22.222 + difficultyRamp) + Math.random() * 10;
      }

      // ============== UPDATE OBSTACLES ==============================
      function updateObstacles(deltaTime) {
        obstacles.forEach((obs) => {
          if (!obs.visible) return;
          obs.position.z -= obs.userData.speed * deltaTime;
          if (obs.position.z < MTC.position.z - 200) {
            obs.visible = false;
          }
        });
      }

      // ============== COLLISION DETECTION ===========================
      function checkCollisions() {
        if (!MTC) return;
        const carBox = new THREE.Box3().setFromObject(MTC).expandByScalar(0.3);
        obstacles.forEach((obs) => {
          if (!obs.visible) return;
          const obsBox = new THREE.Box3().setFromObject(obs).expandByScalar(0.3);
          if (carBox.intersectsBox(obsBox)) {
            handleCollision();
            obs.visible = false;
          }
        });
      }

      // ============== HANDLE COLLISION ==============================
      function handleCollision() {
        collisionCount++;
        console.log(`Collision #${collisionCount}`);
        if (collisionCount < 3) {
          displayWarningIndicator();
        } else {
          triggerGameOver();
        }
      }
      function displayWarningIndicator() {
        const warningIndicator = document.getElementById('warningIndicator');
        if (collisionCount === 1) {
          warningIndicator.style.display = 'block';
          warningIndicator.classList.add('flashing');
        } else if (collisionCount === 2) {
          warningIndicator.classList.remove('flashing');
          warningIndicator.style.animation = 'flash 0.5s infinite';
        }
      }

      // ============== GAME OVER =====================================
      function triggerGameOver() {
        if (gameOver) return;
        gameOver = true;
        cancelAnimationFrame(animationId);
        document.getElementById('finalTime').textContent = formatTime(elapsedTime);
        document.getElementById('gameOver').style.display = 'block';
        document.getElementById('speedometer').style.display = 'none';
        document.getElementById('warningIndicator').style.display = 'none';
      }

      // ============== GAME COMPLETE =================================
      function handleGameCompletion() {
        gameCompleted = true;
        cancelAnimationFrame(animationId);
        document.getElementById('completionTime').textContent = formatTime(elapsedTime);
        updateLeaderboard();
        document.getElementById('gameComplete').style.display = 'block';
        document.getElementById('speedometer').style.display = 'none';
        document.getElementById('warningIndicator').style.display = 'none';
        obstacles.forEach((obs) => (obs.visible = false));
        obstacles = [];
      }

      // ============== LEADERBOARD ===================================
      function updateLeaderboard() {
        let position = null;
        for (let i = 0; i < leaderboard.length; i++) {
          if (elapsedTime < leaderboard[i].time) {
            position = i;
            break;
          }
        }
        if (leaderboard.length < 10 && position === null) {
          position = leaderboard.length;
        }
        if (position !== null) {
          document.getElementById('nameInputContainer').style.display = 'block';
          const submitButton = document.getElementById('submitNameButton');
          submitButton.replaceWith(submitButton.cloneNode(true));
          const newSubmit = document.getElementById('submitNameButton');
          newSubmit.addEventListener('click', () => {
            const name = document.getElementById('nameInput').value.trim() || 'Anonymous';
            leaderboard.splice(position, 0, { name, time: elapsedTime });
            if (leaderboard.length > 10) {
              leaderboard.pop();
            }
            localStorage.setItem('leaderboard', JSON.stringify(leaderboard));
            displayLeaderboard();
            document.getElementById('nameInputContainer').style.display = 'none';
            document.getElementById('gameComplete').style.display = 'none';
          });
        } else {
          displayLeaderboard();
        }
        updateBestTimeDisplay();
      }
      function displayLeaderboard() {
        const leaderboardList = document.getElementById('leaderboardList');
        leaderboardList.innerHTML = '';
        leaderboard.forEach((entry, index) => {
          const li = document.createElement('li');
          let medal = '';
          if (index === 0) medal = '🥇';
          else if (index === 1) medal = '🥈';
          else if (index === 2) medal = '🥉';
          else medal = `${index + 1}.`;
          li.innerHTML = `<span>${medal} ${entry.name}</span><span>${formatTime(entry.time)}</span>`;
          leaderboardList.appendChild(li);
        });
      }
      function updateBestTimeDisplay() {
        if (leaderboard.length > 0) {
          document.getElementById('bestTime').textContent = `Best Time: ${formatTime(leaderboard[0].time)}`;
        } else {
          document.getElementById('bestTime').textContent = 'Best Time: N/A';
        }
      }

      // ============== FORMATTING TIME ===============================
      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        const millis = Math.floor((seconds % 1) * 1000);
        return `${mins}:${secs < 10 ? '0' : ''}${secs}.${millis}`;
      }

      // ============== ANIMATION LOOP ================================
      function animate() {
        if (gameOver || gameCompleted) return;
        animationId = requestAnimationFrame(animate);

        const now = Date.now();
        const deltaTime = (now - previousTime) / 1000;
        previousTime = now;

        // Elapsed
        elapsedTime = (now - startTime) / 1000;
        document.getElementById('time').textContent = `Time: ${formatTime(elapsedTime)}`;

        // Difficulty
        difficultyRamp = elapsedTime * 0.2; // mild increase

        // Distance
        distance += velocity * deltaTime;
        document.getElementById('distance').textContent = `Distance: ${distance.toFixed(1)} m`;

        // Score
        scoreboard = Math.floor(distance);
        document.getElementById('score').textContent = `Score: ${scoreboard}`;

        // Check completion
        if (distance >= 1000) {
          handleGameCompletion();
          return;
        }

        // Accel/Decel
        if (accelerateInput) {
          velocity = Math.min(velocity + 5 * deltaTime, maxVelocity);
        } else if (decelerateInput) {
          velocity = Math.max(velocity - 5 * deltaTime, minVelocity);
        } else {
          // mild inertia
          if (velocity > baseVelocity) {
            velocity = Math.max(velocity - 2 * deltaTime, baseVelocity);
          } else if (velocity < baseVelocity) {
            velocity = Math.min(velocity + 2 * deltaTime, baseVelocity);
          }
        }

        // Speedometer
        document.getElementById('speedometer').textContent = `${(velocity * 3.6).toFixed(0)} km/h`;

        // Car forward movement
        if (MTC) {
          MTC.position.z -= velocity * deltaTime;
        }

        // L-R Steering
        if (moveLeft) {
          MTC.position.x -= 0.05;
          MTC.rotation.z = 0.1;
        } else if (moveRight) {
          MTC.position.x += 0.05;
          MTC.rotation.z = -0.1;
        } else {
          MTC.rotation.z *= 0.9;
        }

        // Obstacle updates
        updateObstacles(deltaTime);
        obstacleTimer += deltaTime;
        if (obstacleTimer >= obstacleFrequency) {
          spawnObstacle();
          obstacleTimer = 0;
        }

        // Collisions
        checkCollisions();

        // Camera follow
        updateCamera();

        renderer.render(scene, camera);
      }

      function updateCamera() {
        if (!MTC) return;
        const desiredPos = new THREE.Vector3(MTC.position.x, 5, MTC.position.z + 15);
        camera.position.lerp(desiredPos, 0.1);
        camera.lookAt(MTC.position.x, MTC.position.y, MTC.position.z);
      }

      // ============== JOYSTICK ==========================
      const joystickBase = document.getElementById('joystick-base');
      const joystickKnob = document.getElementById('joystick-knob');
      let joystickActive = false;
      let joystickMaxDistance = 0;
      let joystickX = 0;
      let joystickY = 0;

      function initJoystick() {
        joystickMaxDistance = joystickBase.offsetWidth / 2;

        joystickBase.addEventListener('touchstart', onJoystickStart, { passive: false });
        joystickBase.addEventListener('touchmove', onJoystickMove, { passive: false });
        joystickBase.addEventListener('touchend', onJoystickEnd, { passive: false });

        joystickBase.addEventListener('mousedown', onJoystickStart, { passive: false });
        document.addEventListener('mousemove', onJoystickMove, { passive: false });
        document.addEventListener('mouseup', onJoystickEnd, { passive: false });
      }

      function onJoystickStart(e) {
        e.preventDefault();
        joystickActive = true;
        joystickKnob.classList.add('active');
        updateJoystick(e);
      }
      function onJoystickMove(e) {
        if (!joystickActive) return;
        e.preventDefault();
        updateJoystick(e);
      }
      function onJoystickEnd(e) {
        if (!joystickActive) return;
        e.preventDefault();
        joystickActive = false;
        joystickKnob.classList.remove('active');
        joystickKnob.style.transition = 'transform 0.3s ease';
        joystickKnob.style.transform = 'translate(0,0)';
        setTimeout(() => {
          joystickKnob.style.transition = 'transform 0.1s ease';
          joystickX = 0;
          joystickY = 0;
        }, 300);
        accelerateInput = false;
        decelerateInput = false;
        moveLeft = false;
        moveRight = false;
      }
      function updateJoystick(e) {
        let clientX, clientY;
        let rect = joystickBase.getBoundingClientRect();

        if (e.touches) {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }

        let x = clientX - rect.left - rect.width / 2;
        let y = clientY - rect.top - rect.height / 2;

        let dist = Math.sqrt(x * x + y * y);
        let angle = Math.atan2(y, x);
        let clampedDist = Math.min(dist, joystickMaxDistance);

        joystickX = (clampedDist * Math.cos(angle)) / joystickMaxDistance;
        joystickY = (clampedDist * Math.sin(angle)) / joystickMaxDistance;

        const knobX = joystickX * joystickMaxDistance * 0.6;
        const knobY = joystickY * joystickMaxDistance * 0.6;
        joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;

        const deadZone = 0.2;
        accelerateInput = joystickY > deadZone;
        decelerateInput = joystickY < -deadZone;
        moveLeft = joystickX < -deadZone;
        moveRight = joystickX > deadZone;
      }

      // ============== START / RESTART ===============================
      function startGame() {
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('instructions').style.display = 'block';
        startCameraAnimation();
      }
      function startCameraAnimation() {
        const startPos = new THREE.Vector3(0, 30, 100);
        const endPos = new THREE.Vector3(0, 5, 15);
        const duration = 1500;
        const start = Date.now();
        camera.position.copy(startPos);
        camera.lookAt(0, 0, 0);

        function animateCam() {
          const now = Date.now();
          const t = Math.min((now - start) / duration, 1);
          camera.position.lerpVectors(startPos, endPos, t);
          camera.lookAt(0, 0, 0);
          if (t < 1) {
            requestAnimationFrame(animateCam);
          } else {
            resetGameState();
            animate();
          }
        }
        animateCam();
      }
      function resetGameState() {
        collisionCount = 0;
        distance = 0;
        scoreboard = 0;
        velocity = baseVelocity;
        gameOver = false;
        gameCompleted = false;

        document.getElementById('gameOver').style.display = 'none';
        document.getElementById('gameComplete').style.display = 'none';
        document.getElementById('warningIndicator').style.display = 'none';
        document.getElementById('warningIndicator').classList.remove('flashing');
        document.getElementById('warningIndicator').style.animation = '';

        if (MTC) {
          MTC.position.set(0, 1.1, 0);
          MTC.rotation.set(0, 0, 0);
        }
        obstacles.forEach((obs) => (obs.visible = false));
        obstacleTimer = 0;
        previousTime = Date.now();
        startTime = previousTime;

        updateBestTimeDisplay();
      }

      function onRestart() {
        resetGameState();
        animate();
      }
      function onContinue() {
        window.location.href = 'https://air.zone';
      }

      // ============== MAIN ==========================================
      // Initialize everything
      initScene();
      loadModels();
      setupEnvironment();
      initJoystick();

      // Pre-wire event listeners
      document.getElementById('play-button').addEventListener('click', startGame);
      document.getElementById('restartButton').addEventListener('click', onRestart);
      document.getElementById('continueLink').addEventListener('click', onContinue);
      document.getElementById('restartButtonComplete').addEventListener('click', onRestart);
      document.getElementById('continueLinkComplete').addEventListener('click', onContinue);

      // Delay obstacle pool init so taxiModel can load
      setTimeout(() => {
        initObstaclePool();
      }, 3000);

      displayLeaderboard();
      updateBestTimeDisplay();
    </script>
  </body>
</html>
